#
# make all
#

#
# Configure your CC65 location
#

# These first entries are synonyms for directory names
CC65=/Users/kate/Applications/cc65
CC65_BIN=$(CC65)/bin
CC65_INC=$(CC65)/include
CC65_TARGET=$(CC65)/target
CC65_ASMINC=$(CC65)/asminc	# the include files for assembler code 
CC65_TOOLS=$(CC65)/wbin

# BUILDDIR is a place for the current build artifacts. 
BUILDDIR=$(MAKEDIR)/$(BUILD)
# ODIR is the folder where intermediate build files like object files can be stored.
ODIR=$(MAKEDIR)/obj

# These two definitions are specific for the NMake tool.
# SUFFIXES lists the extensions of files that while be recognized
.SUFFIXES : .c .s .o .asm .bmp .pal .spr
.SOURCE : 

# Compiling for Atari Lynx system
SYS=lynx

# Shorthand names for the various tools in the compiler suite
# The first five are the compilers and linker
#  SPRPCK is the sprite utility from the BLL toolkit 
CO=co65
CC=cc65
AS=ca65
AR=ar65
CL=cl65
SPRPCK=sprpck
CP=cp
RM=rm
ECHO=echo
TOUCH=touch

# The segment definitions are needed for the compiler, assembler and linker
# default names for the segments
# In a simple compilation such as the one the defaults will be enough.
CODE_SEGMENT=CODE
DATA_SEGMENT=DATA
RODATA_SEGMENT=RODATA
BSS_SEGMENT=BSS

# The SEGMENTS definition is a convenience label for the compiler that holds all four individual segments that the compiler 
# knows about (code, read-only data, bss and data).
SEGMENTS=--code-name $(CODE_SEGMENT) --rodata-name $(RODATA_SEGMENT) --bss-name $(BSS_SEGMENT) --data-name $(DATA_SEGMENT)

# Flag for assembler
AFLAGS=

#
# Flags for C-code compiler
# The two flag definitions are made to capture all assembler and compiler switches that are used
#
# -I .
#   The include directory for header files is the current directory (where the mak file is located)
# -t $(SYS)
#   The target for the compiler is the system defined in SYS, which is “lynx” in our case.
# –add-source
#   Include the source code as comment inside of the generated assembler files. 
#   This will help understand what the original C source code was for the assembler instructions 
#   that were generated by the compiler.
# -O –Or –Os
#   Switches for optimization. In particular and in order: optimize the code, enable register 
#   variables and inline some known functions.
# -Cl
#   Make local variables static
#

CFLAGS=-I . -t $(SYS) --add-source -O -Or -Cl -Os

# various rules that are used by the NMake tool to figure out how to build the desired output files
#
# Rule for making a *.o file out of a *.s file
# This rule defines how a .o file can be created from a .s file. You need the AS65 assembler 
# targeting SYS (our lynx) with an include folder set to the assembler include location 
# specified at the beginning.
#
# the –o switch indicates the output file name. It is set to $@ which is short for the target of the rule.
# example, if this rule is applied to a file interrupt.s, $@ will be equal to interrupt.o
#
# Finally the input (or source) file is provided by $<, a notation for the input file of this rule
# eg: ca65 -t lynx -I "C:\Program Files (x86)\CC65"\asminc -o interrupt.o interrupt.s 
#
.s.o:
	$(AS) -t $(SYS) -I $(CC65_ASMINC) -o $@ $(AFLAGS) $<

# 1. Run the CC65 compiler
# Use the output and run it through the assembler.
# Rule for making a *.o file out of a *.c file
#
# The compiler is run with the segments and flags
# The compiler takes the original source file as input.
# The output of the rule is tutorial.o, which is what the assembler uses as –o output switch with $@. 
# The assembler flags are applied  and the input in this case is the file that was generated by the compiler
# 

.c.o:
	$(CC) $(SEGMENTS) $(CFLAGS) $<
	$(AS) -o $@ $(AFLAGS) $(*).s

# additional rules that create two specific files for the TGI graphics library and joystick support: 
# lynx-160-102-16.o and lynx-stdjoy.o respectively
lynx-stdjoy.o:
	$(CP) $(CC65_TARGET)/lynx/drv/joy/$*.joy .
	$(CO) --code-label _lynxjoy $*.joy
	$(AS) -t lynx -o $@ $(AFLAGS) $*.s
	$(RM) $*.joy
	$(RM) $*.s

# This rule copies the tgi file from the TFI directory inside the CC65 include folder. 
# It then runs the CO65.exe tool to convert the driver’s “o65 object file back into the 
# native object file format used by the cc65 tool chain”.

lynx-160-102-16.o:
	$(CP) $(CC65_TARGET)/lynx/drv/tgi/$*.tgi .
	$(CO) --code-label _lynxtgi $*.tgi
	$(AS) -t lynx -o $@ $(AFLAGS) $*.s
	$(RM) $*.tgi
	$(RM) $*.s

# Rule for making a *.o file out of a *.bmp file
.bmp.o:
	$(SPRPCK) -v -t6 -p2 $<
	$(ECHO) .global _$* > $*.s
	$(ECHO) .segment '"$(RODATA_SEGMENT)"' >> $*.s
	$(ECHO) _$*: .incbin '"$*.spr"' >> $*.s
	$(AS) -t lynx -o $@ $(AFLAGS) $*.s
	$(RM) $*.s
	$(RM) $*.pal
	$(RM) $*.spr

#
# GAME SPECIFIC ENTRIES
#

# target name of the generation lynx output rom
target = color.lnx

#
# CHANGE THE NAME HERE of the input file(s) required to build the rom
#
objects = lynx-160-102-16.o lynx-stdjoy.o sprite.o alien.o

$(target) : $(objects)
	$(CL) -t $(SYS) -o $@ $(objects) lynx.lib
#	$(CP) $@ ./$(BUILD)/$@

all: $(target)

clean:
	$(RM) -f *.tgi
	$(RM) -f *.s
	$(RM) -f *.joy
	$(RM) -f *.o
	$(RM) -f *.lnx